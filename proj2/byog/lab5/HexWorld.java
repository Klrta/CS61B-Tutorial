package byog.lab5;
import org.junit.Test;
import static org.junit.Assert.*;

import byog.TileEngine.TERenderer;
import byog.TileEngine.TETile;
import byog.TileEngine.Tileset;

import java.util.Random;

/**
 *做一个包含六边形的画布
 * 六边形占有5列,每一列分别有3,4,5,4,3个六边形
 */
public class HexWorld {
    /*定义六边形的大小
    * 定义一列中最多能有几个六边形
    * 定义随机用的种子(用于随机生成六边形里瓦片)*/
    private static final int HEXAGON_SIZE = 4;
    private static final int MAX_NUM_VERTICAL_HEXES = 5;
    private static final long SEED = 2873122;
    private static final Random RANDOM = new Random(SEED);

    public static void main(String[] args) {
        /*计算画布的高度*/
        final int HEIGHT = MAX_NUM_VERTICAL_HEXES * calculateHeight(HEXAGON_SIZE);
        /*计算六边形的位置,对于MAX_NUM_VERTICAL_HEXES列
        * 起始位置是六边形的左下角 */
        Point p0 = new Point(0,calculateHeight(HEXAGON_SIZE));
        Point p1 = bottomRightNeighborPosition(p0,HEXAGON_SIZE);
        Point p2 = bottomRightNeighborPosition(p1,HEXAGON_SIZE);
        Point p3 = topRightNeighborPosition(p2,HEXAGON_SIZE);
        Point p4 = topRightNeighborPosition(p3,HEXAGON_SIZE);
        /*计算画布的宽度*/
        Point p5 = bottomRightNeighborPosition(p4,HEXAGON_SIZE);
        final int WIDTH = p5.x + HEXAGON_SIZE;

        /*初始化画版*/
        // Initialize the tile rendering engine with a window of size WIDTH x HEIGHT
        TERenderer ter = new TERenderer();
        ter.initialize(WIDTH,HEIGHT);
        /*初始化画板上的瓦片*/
        TETile[][] world = new TETile[WIDTH][HEIGHT];
        for(int x = 0; x < WIDTH ; x++){
            for(int y = 0; y < HEIGHT;y++){
                world[x][y] = Tileset.NOTHING;
            }
        }
        /*绘制六边形列*/
        drawRandomVerticalHexes(p0,3,HEXAGON_SIZE,world);
        drawRandomVerticalHexes(p1,4,HEXAGON_SIZE,world);
        drawRandomVerticalHexes(p2,5,HEXAGON_SIZE,world);
        drawRandomVerticalHexes(p3,4,HEXAGON_SIZE,world);
        drawRandomVerticalHexes(p4,3,HEXAGON_SIZE,world);

        /*把画布展示*/
        ter.renderFrame(world);

    }
    /**
     * 绘制一列六边形,
     * @param p 六边形原点.
     * @param n 一列里的六边形数量.
     * @param size 规定的尺寸.
     * @param world 画布.
     */
    private static void drawRandomVerticalHexes(Point p, int n, int size, TETile[][] world) {
        int height = calculateHeight(size);
        for(int i = 0;i< n ;i++){
            int x = p.x;
            int y = p.y + i * height;
            TETile tile = randomTile();
            addHexagon(x,y,size,tile,world);
        }
    }
    /**
     * Generates an hexagonal region, comprised of tiles.
     * The hexagon is generated by drawing the columns that make it, one by one.
     * The sides of the hexagon are the lower, upper, lower left and right, and upper left and right.
     * Example of an hexagon of size 3 (+ is the (x, y) coordinate of the hexagon):
     *     ***
     *    *****
     *   *******
     *   *******
     *    *****
     *   + ***
     * @param x 原点x坐标
     * @param y 原点y坐标
     * @param size 规定的尺寸.
     * @param tile roll到的瓦片种类
     * @param world 画布.
     */
    private static void addHexagon(int x, int y, int size, TETile tile, TETile[][] world) {
        int height = calculateHeight(size);
        int[] numTilesPerColumn = calculateNumberTilesPerColumn(size);
        int numCols = numTilesPerColumn.length;
        for (int c = 0; c < numCols; c++) {
            int numTileInCol = numTilesPerColumn[c];
            int yOffset = (height - numTileInCol) / 2;
            addColumn(world,x,y,c,yOffset,numTileInCol,tile);
        }
    }

    /**
     * Draws a column of tiles, at the offset of the y position of the given column.
     * @param world 画布.
     * @param x is the base y position from where to start drawing the tiles.
     * @param y is the base y position from where to start drawing the tiles.
     * @param xOffset is the offset from x, from where the drawing starts.
     * @param yOffset is the offset from y, from where the drawing starts.
     * @param numTiles is the number of tiles to be drawn.
     * @param tile is the type of tile to be drawn.
     */
    private static void addColumn(TETile[][] world, int x, int y, int xOffset, int yOffset, int numTiles, TETile tile) {
        int start = y + yOffset;
        int end  = start + numTiles;
        for(int r = start ; r < end ;r++){
            world[x+xOffset][r] = tile;
        }
    }

    private static int[] calculateNumberTilesPerColumn(int size) {
        int numCols = (size - 1) + size + (size - 1);//每个六边形需要画的列数
        int[] numTilesPerColumn = new int[numCols];
        int height = calculateHeight(size);
        for(int i =0;i<numCols;i++){//算六边形每一列tile
            if (i < size - 1) {
                numTilesPerColumn[i] = 2 * (i+1);
            }else if(i>= 2 *(size - 1)){
                numTilesPerColumn[i] = 2 * (numCols - i);
            }else{
                numTilesPerColumn[i] = height;
            }
        }
        return numTilesPerColumn;
    }

    private static TETile randomTile() {
        int tileNum = RANDOM.nextInt(7);
        switch (tileNum){
            case 0:return Tileset.FLOWER;
            case 1:return Tileset.TREE;
            case 2:return Tileset.WALL;
            case 3:return Tileset.MOUNTAIN;
            case 4:return Tileset.SAND;
            case 5:return Tileset.WATER;
            case 6:return Tileset.GRASS;
            default:return Tileset.NOTHING;
        }
    }

    private static Point topRightNeighborPosition(Point p, int size) {
        int x = p.x + size + (size - 1);
        int y = p.y + size;
        return new Point(x,y);
    }

    private static Point bottomRightNeighborPosition(Point p, int size) {
        int x = p.x + size + (size - 1);
        int y = p.y - size;
        return new Point(x,y);
    }

    private static int calculateHeight(int size) {
        return 2 * size;
    }

}